# 1. 程序的组成、存储与运行

- [1. 程序的组成、存储与运行](#1-程序的组成存储与运行)
  - [1.1. CODE、RO、RW、ZI Data 域及堆栈空间](#11-coderorwzi-data-域及堆栈空间)
  - [1.2. 程序的存储与运行](#12-程序的存储与运行)

## 1.1. CODE、RO、RW、ZI Data 域及堆栈空间
> 在工程的编译提示输出信息中有一个语句“Program Size：Code=xx RO-data=xx RW-data=xx ZI-data=xx”，它说明了程序各个域的大小，编译后，应用程序中所有具有同一性质的数据 (包括代码) 被归到一个域，程序在存储或运行的时候，不同的域会呈现不同的状态，这些域的意义如下：
> ### Code
> 即代码域，它指的是编译器生成的机器指令，这些内容被存储到 ROM 区。
>
> ### RO-data
> Read Only data，即只读数据域，它指程序中用到的只读数据，这些数据被存储在ROM 区，因而程序不能修改其内容。例如 C 语言中 const 关键字定义的变量就是典型的RO-data。
>
> ### RW-data
> Read Write data，即可读写数据域，它指初始化为“非 0 值”的可读写数据，程序刚运行时，这些数据具有非 0 的初始值，且运行的时候它们会常驻在 RAM 区，因而应用程序可以修改其内容。例如 C 语言中使用定义的全局变量，且定义时赋予“非 0 值”给该变量进行初始化。
>
> ### ZI-data
> Zero Initialize data，即 0 初始化数据，它指初始化为“0 值”的可读写数据域，它与RW-data 的区别是程序刚运行时这些数据初始值全都为 0，而后续运行过程与 RW-data 的性质一样，它们也常驻在 RAM 区，因而应用程序可以更改其内容。例如 C 语言中使用定义的全局变量，且定义时赋予“0 值”给该变量进行初始化 (若定义该变量时没有赋予初始值，编译器会把它当 ZI-data 来对待，初始化为 0)；
>
> ### ZI-data 的栈空间 (Stack) 及堆空间 (Heap)
> 在 C 语言中，函数内部定义的局部变量属于栈空间，进入函数的时候从向栈空间申请内存给局部变量，退出时释放局部变量，归还内存空间。而使用 malloc 动态分配的变量属于堆空间。在程序中的栈空间和堆空间都是属于ZI-data 区域的，这些空间都会被初始值化为 0 值。编译器给出的 ZI-data 占用的空间值中包含了堆栈的大小 (经实际测试，若程序中完全没有使用 malloc 动态申请堆空间，编译器会优化，不把堆空间计算在内)。

## 1.2. 程序的存储与运行