# 1. 文件类型

- [1. 文件类型](#1-文件类型)
  - [1.1. Project 目录下的工程文件](#11-project-目录下的工程文件)
  - [1.2. 源文件](#12-源文件)
  - [1.3. Objects 目录下的文件](#13-objects-目录下的文件)
  - [1.4. Listing 目录下的文件](#14-listing-目录下的文件)
  - [1.5. 其他](#15-其他)

## 1.1. Project 目录下的工程文件

> ### 1.1.3. *.uvguix 文件
>
> MDK5 工程的窗口布局文件，在MDK4中 *。UVGUI 后缀的文件功能相同。这个文件包含了 Keil µVision GUI（图形用户界面）的布局和设置信息。这可能包括窗口大小、位置，以及其他个性化的界面设置。
>
> ### 1.1.1. *.uvprojx 文件
>
> MDK5 的工程文件，它使用了 XML 格式记录了工程结构，双击它可以打开整个工程，在 MDK4 中 *.UVPROJ 后缀的文件功能相同。这是 Keil µVision 项目文件，它包含了项目的核心配置信息。这包括目标硬件、编译器选项、链接器选项、包含的源文件等。通常，这个文件会在你创建一个新项目时自动生成。
>
> ### 1.1.2. *.uvoptx 文件
>
> MDK5 的工程配置选项， 包含 debugger、trace configuration、breakpooints 以及当前打开的文件，在 MDK4 中 *.UVOPT 后缀的文件功能相同。 这个文件是与项目相关的设置和选项的存储位置，但主要是那些不直接影响编译和构建过程的设置。这通常包括调试设置、断点信息和其他用户自定义设置。这些信息通常是特定于开发者的。
>
> ### 1.1.3. *.ini 文件
>
> 某些下载器的配置记录文件

## 1.2. 源文件

源文件是工程中我们最熟悉的内容了，它们就是我们编写的各种源代码，MDK 支持 c、cpp、h、s、inc 类型的源代码文件，其中 c、cpp 分别是 c/c++ 语言的源代码，h 是它们的头文件，s 是汇编文件，inc 是汇编文件的头文件，可使用“$include”语法包含。编译器根据工程中的源文件最终生成机器码。

> ### 1.2.1. *.c 文件
>
> C 语言源文件。
>
> ### 1.2.2. *.cpp 文件
>
> C++ 语言源文件。
>
> ### 1.2.3. *.h 文件
>
> C/C++ 的头文件。
>
> ### 1.2.4. *.s 文件
>
> 汇编语言的源文件。
>
> ### 1.2.5. *.inc 文件
>
> 汇编语言的头文件（使用 “$include” 来包含）。
>

## 1.3. Objects 目录下的文件

> ### 1.3.1. *.lib 文件
>
> 库文件。在某些场合下我们希望提供给第三方一个可用的代码库，但不希望对方看到源码，这个时候我们就可以把工程生成 lib 文件 (Library file) 提供给对方。
>
> 得到生成的 \*.lib 文件后，可把它像 C 文件一样添加到其它工程中，并在该工程调用 lib 提供的函数接口，除了不能看到 \*.lib 文件的源码，在应用方面它跟 C 源文件没有区别。
>
> ### 1.3.2. *.dep 文件（Dependency 文件）
>
> 整个工程的依赖文件：这个文件列出了源代码文件（如 .c、.cpp 等）的依赖关系，通常用于增量编译。当修改了某个头文件时，编译器可以通过查看 .dep 文件来决定哪些源文件需要重新编译。
>
> ### 1.3.3. *.d 文件（Dependency 文件）
>
> 描述了对应 .o 的依赖文件：与 .dep 文件类似，这个文件也包含了源文件的依赖信息。它通常用于 GNU Make 或其他构建系统，在进行增量编译时确定哪些文件需要重新编译。
>
> ### 1.3.4. *.crf 文件（Cross-Reference 文件）
>
> 交叉引用文件，包含了浏览信息（定义，引用及标识符）：这个文件包含了源代码与其生成的目标代码之间的交叉引用信息。这通常用于更高级的代码分析或文档生成。
>
> \*.crf 是交叉引用文件 (Cross-Reference file)，它主要包含了浏览信息 (browse information)，即源代码中的宏定义、变量及函数的定义和声明的位置。我们在代码编辑器中点击“Go To Definition Of ‘xxxx’”可实现浏览跳转，见图浏览信息 ，跳转的时候，MDK 就是通过 *.crf 文件查找出跳转位置的。通过配置 MDK 中的“Option for Target->Output->Browse Information”选项可以设置编译时是否生成浏览信息。只有勾选该选项并编译后，才能实现浏览跳转功能。
>
> ### 1.3.5. *.o 文件（Object 文件）
>
> 可重定位的对象文件（目标文件）：这是编译后生成的目标文件。这些 .o 文件会被链接器合并成一个可执行文件或库。
>
> ### 1.3.6. *.bin 文件
>
> 二进制格式的映像文件，是纯粹的 FLASH 映像，不含任何额外信息。
>
> ### 1.3.7. *.hex 文件
>
> Intel Hex 格式的映像文件，可理解为带存储地址描述格式的 bin 文件。
>
> hex 是Intel 公司制定的一种使用ASCII 文本记录机器码或常量数据的文件格式，这种文件常常用来记录将要存储到ROM 中的数据，绝大多数下载器支持该格式。
>
> ### 1.3.8. *.axf 文件
>
> 由 ARMCC 编译生成的可执行对象文件，可用于调试，该文件不可重定义。
>
> - hex、bin 及axf 文件的区别与联系
>   - bin、hex 及axf 文件都包含了指令代码，但它们的信息丰富程度是不一样的。
>   - bin 文件是最直接的代码映像，它记录的内容就是要存储到FLASH 的二进制数据(机器码本质上就是二进制数据)，在FLASH 中是什么形式它就是什么形式，没有任何辅助信息，包括大小端格式也没有，因此下载器需要有针对芯片FLASH 平台的辅助文件才能正常下载(一般下载器程序会有匹配的这些信息)；
>   - hex 文件是一种使用十六进制符号表示的代码记录，记录了代码应该存储到FLASH 的哪个地址，下载器可以根据这些信息辅助下载；
>   - axf 文件在前文已经解释，它不仅包含代码数据，还包含了工程的各种信息，因此它也是三个文件中最大的。
>
> ### 1.3.9. *.elf 文件
>
> 由 GCC 编译生成的文件，功能跟 axf 文件一样，该文件不可重定位。
>
> ELF 是 Executable and Linking Format 的缩写，译为可执行链接格式，该格式用于记录目标文件的内容。在 Linux 及 Windows 系统下都有使用该格式的文件 (或类似格式) 用于记录应用程序的内容，告诉操作系统如何链接、加载及执行该应用程序。
>
> #### **目标文件三种类型**
>
> - 可重定位的文件(Relocatable File)
>   - 包含基础代码和数据，但它的代码及数据都没有指定绝对地址，因此它适合于与其他目标文件链接来创建可执行文件或者共享目标文件。这种文件一般由编译器根据源代码生成。
>   - 例如MDK 的 armcc 和 armasm 生成的 \*.o 文件就是这一类，另外还有 Linux 的\*.o 文件，Windows 的*.obj 文件。
>
> - 可执行文件(Executable File)
>   - 它包含适合于执行的程序，它内部组织的代码数据都有固定的地址(或相对于基地址的偏移)，系统可根据这些地址信息把程序加载到内存执行。这种文件一般由链接器根据可重定位文件链接而成，它主要是组织各个可重定位文件，给它们的代码及数据一一打上地址标号，固定其在程序内部的位置，链接后，程序内部各种代码及数据段不可再重定位(即不能再参与链接器的链接)。
>   - 例如MDK 的armlink 生成的*.elf 及*.axf 文件，(使用gcc 编译工具可生成*.elf 文件，用armlink生成的是*.axf 文件，.axf 文件在.elf 之外，增加了调试使用的信息，其余区别不大，后面我们仅讲解*.axf 文件)，另外还有Linux 的/bin/bash 文件，Windows 的*.exe 文件。
>
> - 共享目标文件(Shared Object File)
>   - 它的定义比较难理解，我们直接举例，MDK 生成的*.lib文件就属于共享目标文件，它可以继续参与链接，加入到可执行文件之中。另外，Linux 的.so，如/lib/ glibc-2.5.so，Windows 的 DLL 都属于这一类。
>
> #### **ELF 文件格式**
>
> - ELF 文件头
>   - ELF 文件头用来描述整个文件的组织，例如数据的大小端格式，程序头、节区头在文件中的位置等。
> - 程序头
>   - 程序头告诉系统如何加载程序，例如程序主体存储在本文件的哪个位置，程序的大小，程序要加载到内存什么地址等等。MDK 的可重定位文件*.o 不包含这部分内容，因为它还不是可执行文件，而armlink 输出的*.axf 文件就包含该内容了。
> - 节区(section)
>   - 节区是*.o 文件的独立数据区域，它包含提供给链接视图使用的大量信息，如指令(Code)、数据(RO、RW、ZI-data)、符号表(函数、变量名等)、重定位信息等，例如每个由C 语言定义的函数在*.o 文件中都会有一个独立的节区；
> - 节区头部表
>   - 存储在最后的节区头则包含了本文件节区的信息，如节区名称、大小等等。
>
> ### 1.3.10. *.sct 文件
>
> 链接器控制文件（分散加载）：在 Keil 环境中，.sct 文件是一个用于描述程序如何在目标硬件的内存中布局的链接脚本文件（Scatter-Load Description File）。这个文件用于定义哪些代码和数据段应该放在哪个内存区域（例如 RAM, FLASH 等）。它的主要目的是为了在编译和链接过程中进行内存分配。
>
> ### 1.3.11. *.scr 文件
>
> 链接器产生的分散加载文件。
>
> ### 1.3.12. *.lnp 文件（Linker Settings 文件）
>
> MDK 生成的链接输入文件，用于调用链接器时的命令输入：这个文件存储了链接器的设置信息，如内存布局、入口点等。它通常用于配置更复杂的链接行为。
>
> ### 1.3.13. *.htm 静态调用图文件（HTML Report 文件）
>
> 链接器生成的静态调用图文件：通常这是一个编译报告，提供了关于构建过程的各种统计信息，比如代码大小、数据段大小等。
>
> ### 1.3.14. *.build_log.htm 静态调用图文件（Build Log HTML 文件）
>
> 构建工程的日志记录文件：这是一个 HTML 格式的构建日志文件，记录了编译过程中的各种信息，如编译日期、时间、使用的编译器版本、警告、错误等。
>

## 1.4. Listing 目录下的文件

在Listing 目录下包含了*.map 及*.lst 文件，它们都是文本格式的，可使用Windows 的记事本软件打开。其中lst 文件仅包含了一些汇编符号的链接信息，我们重点分析map 文件。

> ### 1.4.1. *.lst 文件（Listing 文件）
>
> C 及汇编编译器产生的列表文件：这是一个由编译器生成的汇编级别的列表文件。它通常包含源代码与生成的汇编或机器代码之间的映射，以及其他关于编译过程的信息。这对于低级调试和性能分析非常有用。.lst 文件通常会显示源代码行和相应的汇编指令，以及地址和其他信息。
>
> ### 1.4.2. *.map 文件（Map 文件）
>
> 链接器生成的列表文件，包含存储器映像分布：这是一个由链接器生成的文件，用于描述程序的内存布局。它列出了所有符号（函数、变量等）的地址分配情况，以及如何映射到目标硬件的内存中。.map 文件在调试、分析和优化应用程序时非常有用，特别是在资源受限的嵌入式系统中。
>

## 1.5. 其他

> ### 1.5.1. *.ini 文件
>
> 仿真、下载器的脚本文件。
>

<!-- ### *.dbgconf 文件 -->
<!-- 这个文件通常用于存储调试配置信息。这可能包括断点、内存监视器设置、CPU 寄存器视图等。.dbgconf 文件通常用于在不同的调试会话之间保持这些设置的一致性。这个文件一般是由 IDE（如 Keil）生成的，并可以在之后的调试会话中重新加载。 -->