# 1. 修改寄存器的位操作方法

- [1. 修改寄存器的位操作方法](#1-修改寄存器的位操作方法)
  - [1.1. 把变量的某位清零](#11-把变量的某位清零)
  - [1.2. 把变量的某几个连续位清零](#12-把变量的某几个连续位清零)
  - [1.3. 对变量的某几位进行赋值](#13-对变量的某几位进行赋值)
  - [1.4. 对变量的某位取反](#14-对变量的某位取反)

## 1.1. 把变量的某位清零

```c
// 定义一个变量 a = 1001 1111 b (二进制数)
unsigned char a = 0x9f;

// 对 bit2 清零
a &= ~(1<<2);

// 括号中的 1 左移两位，(1<<2) 得二进制数：0000 0100 b
// 按位取反，~(1<<2) 得 1111 1011 b
// 假如 a 中原来的值为二进制数： a = 1001 1111 b
// 所得的数与 a 作”位与&”运算，a = (1001 1111 b)&(1111 1011 b),
// 经过运算后，a 的值 a=1001 1011 b
// a 的 bit2 位被被零，而其它位不变。
```

## 1.2. 把变量的某几个连续位清零

```c
// 若把 a 中的二进制位分成 2 个一组
// 即 bit0、bit1 为第 0 组，bit2、bit3 为第 1 组，
// bit4、bit5 为第 2 组，bit6、bit7 为第 3 组
// 要对第 1 组的 bit2、bit3 清零

a &= ~(3<<2*1);

// 括号中的 3 左移两位，(3<<2*1) 得二进制数：0000 1100 b
// 按位取反，~(3<<2*1) 得 1111 0011 b
// 假如 a 中原来的值为二进制数： a = 1001 1111 b
// 所得的数与 a 作”位与&”运算，a = (1001 1111 b)&(1111 0011 b),
// 经过运算后，a 的值 a=1001 0011 b
// a 的第 1 组的 bit2、bit3 被清零，而其它位不变。

// 上述 (~(3<<2*1)) 中的 (1) 即为组编号; 如清零第 3 组 bit6、bit7 此处应为 3
// 括号中的 (2) 为每组的位数，每组有 2 个二进制位; 若分成 4 个一组，此处即为 4
// 括号中的 (3) 是组内所有位都为 1 时的值; 若分成 4 个一组，此处即为二进制数“1111 b”

// 例如对第 2 组 bit4、bit5 清零
a &= ~(3<<2*2);
```

## 1.3. 对变量的某几位进行赋值

```c
// a = 1000 0011 b
// 此时对清零后的第 2 组 bit4、bit5 设置成二进制数“01 b ”

a |= (1<<2*2);
// a = 1001 0011 b，成功设置了第 2 组的值，其它组不变
```

## 1.4. 对变量的某位取反

```c
// a = 1001 0011 b
// 把 bit6 取反，其它位不变

a ^= (1<<6);
// a = 1101 0011 b
```
